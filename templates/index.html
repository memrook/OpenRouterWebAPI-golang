<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memrook's Chat</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="icon" type="image/x-icon" href="/templates/deepseek.svg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .chat-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .reset-button {
            padding: 8px 15px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .reset-button:hover {
            background-color: #c82333;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
        }
        .stream-toggle {
            padding: 8px 15px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .stream-toggle.active {
            background-color: #28a745;
        }
        .stream-toggle:hover {
            opacity: 0.9;
        }
        .input-container {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            position: relative;
        }
        textarea {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            resize: vertical;
            min-height: 50px;
            font-size: 16px;
            font-family: monospace;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            min-width: 120px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .response {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            position: relative;
            transition: all 0.3s ease;
            font-size: 16px;
            line-height: 1.5;
        }
        .response.fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        .response .math {
            margin: 10px 0;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow-x: auto;
        }
        /* Стили для истории сообщений */
        .conversation-history {
            margin-bottom: 20px;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 10px;
        }
        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
        }
        .message-user {
            background-color: #e9f5ff;
            margin-left: 20%;
            border-left: 3px solid #007bff;
        }
        .message-assistant {
            background-color: #f8f9fa;
            margin-right: 20%;
            border-left: 3px solid #28a745;
        }
        .message-role {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .message-content {
            white-space: pre-wrap;
        }
        .model-info {
            font-size: 10px;
            color: #888;
            font-weight: normal;
            margin-left: 5px;
        }
        /* Markdown стили */
        .response h1, .response h2, .response h3, .response h4, .response h5, .response h6,
        .message-content h1, .message-content h2, .message-content h3, .message-content h4, .message-content h5, .message-content h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            color: #2c3e50;
        }
        .response p, .message-content p {
            margin: 1em 0;
            line-height: 1.6;
        }
        .response ul, .response ol, .message-content ul, .message-content ol {
            margin: 1em 0;
            padding-left: 2em;
        }
        .response blockquote, .message-content blockquote {
            margin: 1em 0;
            padding-left: 1em;
            border-left: 4px solid #007bff;
            color: #666;
        }
        .response a, .message-content a {
            color: #007bff;
            text-decoration: none;
        }
        .response a:hover, .message-content a:hover {
            text-decoration: underline;
        }
        .response table, .message-content table {
            border-collapse: collapse;
            margin: 1em 0;
            width: 100%;
        }
        .response th, .response td, .message-content th, .message-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .response th, .message-content th {
            background-color: #f8f9fa;
        }
        .response img, .message-content img {
            max-width: 100%;
            height: auto;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .loading-container {
            display: none;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            animation: pulse 1.5s infinite;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .htmx-request .loading-container {
            display: flex;
        }
        .htmx-request .submit-btn {
            display: none;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .loading-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
            display: inline-block;
            width: 1.5em;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
            80%, 100% { content: ''; }
        }
        .error {
            color: #dc3545;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            animation: shake 0.5s ease-in-out;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        .status-indicator {
            display: none;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 0.9em;
        }
        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status-warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        .status-loading {
            background-color: #cce5ff;
            color: #004085;
            border: 1px solid #b8daff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-loading::after {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(0,64,133,0.3);
            border-radius: 50%;
            border-top-color: #004085;
            animation: spin 1s ease-in-out infinite;
        }
        /* Стили для LaTeX блоков */
        .latex-block {
            margin: 15px 0;
            padding: 15px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            font-size: 1.1em;
        }
        /* Стили для inline LaTeX */
        .latex-inline {
            padding: 0 5px;
        }
        /* Стили для блоков кода */
        .code-block, pre {
            margin: 15px 0;
            padding: 15px;
            background-color: #282c34;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .code-block code, pre code {
            padding: 0;
            background: none;
            white-space: pre;
            color: #f8f8f2;
        }
        /* Стили для inline кода */
        code:not(.code-block code):not(pre code) {
            background-color: #f3f4f5;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }
        /* Добавляем стили для индикатора загрузки */
        .loading-spinner {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-left: 5px;
            vertical-align: middle;
            flex-shrink: 0; /* Предотвращает сжатие */
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Стиль для подсказки о горячих клавишах */
        .hotkey-hint {
            position: absolute;
            bottom: -20px;
            right: 0;
            font-size: 12px;
            color: #666;
        }

        /* Стиль для отключенной кнопки во время загрузки */
        .submit-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* Индикатор времени ожидания */
        .response-time {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 12px;
            color: #666;
        }
        
        .context-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            text-align: right;
        }
        
        /* Стиль для кнопки отмены */
        .cancel-btn {
            background-color: #dc3545;
            display: none;
        }
        .cancel-btn:hover {
            background-color: #c82333;
        }
        .streaming .cancel-btn {
            display: inline-block;
        }
        .streaming .submit-btn {
            display: none;
        }
        
        /* Курсор для симуляции набора текста */
        .typing-cursor {
            display: inline-block;
            width: 5px;
            height: 17px;
            background-color: #333;
            margin-left: 2px;
            animation: blink 1s infinite;
            vertical-align: middle;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        
        /* Стиль для сообщения об отмене */
        .cancel-message {
            color: #dc3545;
            font-style: italic;
            margin-top: 5px;
            font-size: 0.9em;
        }
        
        /* Стиль для сообщения об ошибке */
        .error-message {
            color: #dc3545;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        
        /* Стиль для кнопки повторной попытки */
        .retry-btn {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 10px;
            margin-left: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .retry-btn:hover {
            background-color: #0056b3;
        }
        
        /* Стиль для кнопки проверки API */
        .check-api-btn {
            display: none;
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 10px;
        }
        .check-api-btn:hover {
            background-color: #138496;
        }
        .status-error .check-api-btn {
            display: inline-block;
        }
        
        /* Стили для селектора модели */
        .model-selector-container {
            position: relative;
            flex-grow: 1;
            max-width: 300px;
            margin-right: 10px;
            display: flex;
            gap: 5px;
        }
        .model-selector {
            width: 100%;
            padding: 8px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: white;
            font-size: 14px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 30px;
        }
        .model-selector:hover {
            border-color: #aaa;
        }
        .model-selector:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        .model-selector option {
            padding: 8px;
        }
        .refresh-models-btn {
            min-width: auto;
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #6c757d;
        }
        .refresh-models-btn:hover {
            background-color: #5a6268;
        }
        .refresh-models-btn svg {
            fill: white;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="header-container">
            <h1>Deepseek Chat</h1>
            <div class="action-buttons">
                <div class="model-selector-container">
                    <select id="model-selector" class="model-selector" title="Выберите модель ИИ">
                        <option value="loading">Загрузка моделей...</option>
                    </select>
                    <button type="button" class="refresh-models-btn" title="Обновить список моделей" onclick="loadAvailableModels()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                            <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                        </svg>
                    </button>
                </div>
                <button id="stream-toggle" class="stream-toggle active" title="Режим потоковой загрузки ответов">Стриминг: вкл</button>
                <button class="reset-button" 
                        hx-post="/reset" 
                        hx-confirm="Вы уверены, что хотите сбросить всю историю беседы?"
                        hx-target="#conversation-history"
                        hx-swap="innerHTML">Сбросить историю</button>
            </div>
        </div>
        
        <!-- История сообщений -->
        <div id="conversation-history" class="conversation-history">
            {{if .Messages}}
                {{range .Messages}}
                    <div class="message {{if eq .Role "user"}}message-user{{else}}message-assistant{{end}}">
                        <div class="message-role">
                            {{if eq .Role "user"}}
                                Вы
                            {{else}}
                                Ассистент
                                {{if $.CurrentModel}}
                                <span class="model-info">(текущая модель)</span>
                                {{end}}
                            {{end}}
                        </div>
                        <div class="message-content">{{.Content}}</div>
                    </div>
                {{end}}
            {{else}}
                <div class="context-info">История беседы пуста</div>
            {{end}}
        </div>
        
        <form id="message-form">
            <div class="input-container">
                <textarea name="message" 
                         id="message-input"
                         placeholder="Введите ваше сообщение..." 
                         required></textarea>
                <button type="submit" class="submit-btn" id="submit-btn">Отправить</button>
                <button type="button" class="cancel-btn" id="cancel-stream-btn">Отмена</button>
                <div class="loading-container">
                    <span>Генерирую</span>
                    <div class="loading-spinner"></div>
                </div>
                <div class="hotkey-hint">Cmd+Enter / Ctrl+Enter для отправки</div>
            </div>
        </form>
        <div id="response" class="response"></div>
        <div id="status" class="status-indicator">
            <button id="check-api-btn" class="check-api-btn" onclick="checkAPIStatus()">Проверить API</button>
        </div>
        <div class="context-info">
            <span id="message-count">Сообщений в истории: {{len .Messages}}</span>
            <span id="response-time">0.00 сек</span>
        </div>
    </div>

    <script>
        // Настройка Marked
        marked.setOptions({
            highlight: function(code, lang) {
                // Если указан язык и он поддерживается
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (error) {
                        console.error('Ошибка подсветки синтаксиса:', error);
                    }
                }
                // Иначе пробуем автоопределение
                try {
                    return hljs.highlightAuto(code).value;
                } catch (error) {
                    console.error('Ошибка автоопределения синтаксиса:', error);
                    return code; // Возвращаем оригинальный код без подсветки
                }
            },
            breaks: true,
            gfm: true,
            headerIds: true,
            mangle: false
        });

        // Инициализация переменных
        let isWaitingForResponse = false;
        let startTime = null;
        let currentStreamSource = null;
        let currentStreamingResponseId = null;
        let isStreaming = true; // По умолчанию стриминг включен
        let timerInterval = null;
        let historyDiv = document.getElementById('conversation-history');
        let messageInput = document.getElementById('message-input');
        
        // При загрузке DOM
        document.addEventListener('DOMContentLoaded', function() {
            // Обновляем ссылки на элементы DOM
            historyDiv = document.getElementById('conversation-history');
            messageInput = document.getElementById('message-input');
            
            const messageForm = document.getElementById('message-form');
            const submitBtn = document.getElementById('submit-btn');
            const resetBtn = document.getElementById('reset-btn');
            const streamToggle = document.getElementById('stream-toggle');
            const cancelStreamBtn = document.getElementById('cancel-stream-btn');
            const modelSelector = document.getElementById('model-selector');
            
            // Загружаем доступные модели
            loadAvailableModels();
            
            // Обработчик изменения модели
            modelSelector.addEventListener('change', function() {
                if (this.value !== 'loading') {
                    setCurrentModel(this.value);
                }
            });
            
            // Проверяем статус API при загрузке страницы
            checkAPIStatus();
            
            // Форматируем сообщения в истории при загрузке страницы
            document.querySelectorAll('.message-content').forEach(function(element) {
                try {
                    // Сохраняем исходный текст
                    const rawText = element.textContent;
                    
                    // Применяем Markdown
                    element.innerHTML = marked.parse(rawText);
                    
                    // Подсвечиваем код
                    applyHighlightToCodeBlocks(element);
                    
                    // Рендерим LaTeX формулы
                    if (typeof MathJax !== 'undefined') {
                        MathJax.typesetPromise([element]).catch(function (err) {
                            console.error('Ошибка при рендеринге LaTeX:', err);
                        });
                    }
                } catch (error) {
                    console.error('Ошибка при форматировании сообщения:', error);
                }
            });
            
            // Прокручиваем к последнему сообщению
            if (historyDiv) {
                historyDiv.scrollTop = historyDiv.scrollHeight;
            }
            
            // Переключение режима стриминга
            streamToggle.addEventListener('click', function() {
                toggleStreamingMode(!isStreaming);
            });
            
            // Обработчик отмены потокового запроса
            cancelStreamBtn.addEventListener('click', function() {
                cancelStream();
            });
            
            // Горячие клавиши
            document.addEventListener('keydown', function(event) {
                // Ctrl+Enter или Cmd+Enter для отправки формы
                if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                    event.preventDefault();
                    if (!messageInput.value.trim() || isWaitingForResponse) {
                        return;
                    }
                    
                    submitMessage();
                }
                
                // Escape для отмены потокового запроса
                if (event.key === 'Escape' && currentStreamSource) {
                    cancelStream();
                }
            });
            
            // Перехватываем отправку формы
            messageForm.addEventListener('submit', function(event) {
                event.preventDefault();
                
                const message = messageInput.value.trim();
                if (!message || isWaitingForResponse) {
                    return;
                }
                
                submitMessage();
            });
            
            // Обработчик сброса истории
            resetBtn.addEventListener('click', function() {
                if (confirm('Вы уверены, что хотите очистить всю историю диалога?')) {
                    historyDiv.innerHTML = '';
                    document.getElementById('message-count').textContent = 'Сообщений в истории: 0';
                    document.getElementById('response-time').textContent = '0.00 сек';
                    
                    // Отправляем запрос на сервер для очистки истории
                    fetch('/reset', { method: 'POST' })
                    .catch(error => console.error('Ошибка при сбросе истории:', error));
                }
            });
            
            // Инициализируем начальное состояние UI
            updateUIState();
        });
        
        // Функция обновления времени ответа
        function updateResponseTime() {
            if (startTime) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeStr = minutes > 0 ? 
                    `${minutes}м ${seconds}с` : 
                    `${seconds}с`;
                
                document.getElementById('response-time').textContent = `${timeStr}`;
            }
        }
        
        // Основная функция отправки сообщения
        function submitMessage() {
            const submitBtn = document.getElementById('submit-btn');
            const messageInput = document.getElementById('message-input');
            const statusDiv = document.getElementById('status');
            const responseDiv = document.getElementById('response');
            
            // Проверяем, не пустое ли сообщение
            const message = messageInput.value.trim();
            if (!message) return;
            
            // Отключаем элементы формы
            submitBtn.disabled = true;
            messageInput.disabled = true;
            
            // Очищаем предыдущий ответ и статус
            responseDiv.innerHTML = '';
            responseDiv.classList.remove('fade-in');
            statusDiv.style.display = 'none';
            
            // Запускаем таймер
            startTime = Date.now();
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateResponseTime, 1000);
            
            if (isStreaming) {
                // Используем потоковый режим
                handleStreamingRequest(message);
            } else {
                // Используем обычный режим
                handleRegularRequest(message);
            }
        }
        
        // Функция для подсветки синтаксиса в блоках кода
        function applyHighlightToCodeBlocks(container) {
            try {
                const codeBlocks = container.querySelectorAll('pre code');
                codeBlocks.forEach((block) => {
                    const languageClass = [...block.classList].find(cls => cls.startsWith('language-'));
                    if (languageClass) {
                        const language = languageClass.replace('language-', '');
                        if (hljs.getLanguage(language)) {
                            hljs.highlightElement(block);
                        } else {
                            hljs.highlightAuto(block);
                        }
                    } else {
                        hljs.highlightAuto(block);
                    }
                });
            } catch (error) {
                console.error('Ошибка при подсветке кода:', error);
            }
        }

        // Функция для добавления сообщения пользователя в историю
        function addUserMessageToHistory(message) {
            const userMessageDiv = document.createElement('div');
            userMessageDiv.className = 'message message-user';
            
            // Безопасно применяем Markdown к сообщению пользователя
            let formattedUserMessage;
            try {
                formattedUserMessage = marked.parse(message);
            } catch (error) {
                console.error('Ошибка форматирования сообщения пользователя:', error);
                formattedUserMessage = `<pre>${message}</pre>`; // Используем pre для сохранения форматирования
            }
            
            userMessageDiv.innerHTML = `
                <div class="message-role">Вы</div>
                <div class="message-content">${formattedUserMessage}</div>
            `;
            historyDiv.appendChild(userMessageDiv);
            
            // Добавляем подсветку синтаксиса для блоков кода в сообщении пользователя
            applyHighlightToCodeBlocks(userMessageDiv);
            
            // Прокручиваем историю к последнему сообщению
            historyDiv.scrollTop = historyDiv.scrollHeight;
            
            return userMessageDiv;
        }
        
        // Обработка потокового запроса
        function handleStreamingRequest(message) {
            const statusDiv = document.getElementById('status');
            const historyDiv = document.getElementById('conversation-history');
            
            // Создаем уникальный идентификатор для этого ответа
            const responseId = 'streaming-response-' + Date.now();
            
            // Добавляем сообщение пользователя в историю
            const userMessageDiv = addUserMessageToHistory(message);
            
            // Добавляем блок для ответа ассистента
            const streamingResponseDiv = document.createElement('div');
            streamingResponseDiv.id = responseId;
            streamingResponseDiv.className = 'message message-assistant';
            streamingResponseDiv.innerHTML = `
                <div class="message-role">
                    Ассистент
                    <span class="model-info">(${getModelNameById(document.getElementById('model-selector').value)})</span>
                </div>
                <div class="message-content"><div class="typing-cursor"></div></div>
            `;
            historyDiv.appendChild(streamingResponseDiv);
            
            // Прокручиваем историю к последнему сообщению
            historyDiv.scrollTop = historyDiv.scrollHeight;
            
            // Сохраняем идентификатор текущего ответа
            currentStreamingResponseId = responseId;
            
            // Определяем переменные для накопления текста и таймеры
            let accumulatedText = '';
            let partialJSON = '';
            let decoder = new TextDecoder();
            
            // Показываем статус запроса
            statusDiv.className = 'status-indicator status-loading';
            statusDiv.textContent = 'Отправка запроса...';
            statusDiv.style.display = 'block';
            
            // Активируем кнопку отмены потока
            document.getElementById('cancel-stream-btn').disabled = false;
            
            // Запускаем таймер
            startTime = new Date();
            
            // Обновляем счетчик сообщений
            updateMessageCount();
            
            // Устанавливаем флаг, что ожидаем ответ
            isWaitingForResponse = true;
            updateUIState();
            
            // Получаем источник событий сервера
            const evtSource = new EventSource(`/stream?message=${encodeURIComponent(message)}`);
            
            // Сохраняем ссылку на источник событий для возможности отмены
            currentStreamSource = evtSource;
            
            // Добавляем обработчик сообщений
            evtSource.onmessage = function(event) {
                // Показываем статус загрузки
                statusDiv.className = 'status-indicator status-loading';
                statusDiv.textContent = 'Получение ответа...';
                
                // Отладочный вывод в консоль
                console.log('Получено событие:', event.data);
                
                try {
                    // Проверяем, не завершающее ли это сообщение
                    if (event.data === '[DONE]') {
                        console.log('Получен сигнал завершения потока');
                        completeStreaming(streamingResponseDiv);
                        return;
                    }
                    
                    // Парсим JSON ответ
                    const parsedData = JSON.parse(event.data);
                    console.log('Успешно разобран JSON:', parsedData);
                    
                    if (parsedData.choices && parsedData.choices.length > 0) {
                        const delta = parsedData.choices[0].delta;
                        
                        // Проверяем, содержит ли дельта текст
                        if (delta && delta.content) {
                            const deltaContent = delta.content;
                            accumulatedText += deltaContent;
                            
                            // Обновляем содержимое сообщения
                            const contentDiv = streamingResponseDiv.querySelector('.message-content');
                            contentDiv.textContent = accumulatedText;
                            
                            // Добавляем курсор в конец сообщения
                            const cursor = document.createElement('div');
                            cursor.className = 'typing-cursor';
                            contentDiv.appendChild(cursor);
                            
                            // Прокручиваем историю к последнему сообщению
                            historyDiv.scrollTop = historyDiv.scrollHeight;
                        }
                    }
                } catch (error) {
                    console.error('Ошибка при обработке потокового ответа:', error, event.data);
                    
                    try {
                        // Пробуем восстановить частичный JSON
                        partialJSON += event.data;
                        const parsedData = JSON.parse(partialJSON);
                        
                        if (parsedData.choices && parsedData.choices.length > 0) {
                            const delta = parsedData.choices[0].delta;
                            
                            if (delta && delta.content) {
                                const deltaContent = delta.content;
                                accumulatedText += deltaContent;
                                
                                // Обновляем содержимое сообщения
                                const contentDiv = streamingResponseDiv.querySelector('.message-content');
                                contentDiv.textContent = accumulatedText;
                                
                                // Добавляем курсор в конец сообщения
                                const cursor = document.createElement('div');
                                cursor.className = 'typing-cursor';
                                contentDiv.appendChild(cursor);
                                
                                // Прокручиваем историю к последнему сообщению
                                historyDiv.scrollTop = historyDiv.scrollHeight;
                            }
                        }
                        
                        // Сбрасываем частичный JSON
                        partialJSON = '';
                    } catch {
                        // Если не удалось восстановить JSON, просто добавляем текст
                        console.warn('Не удалось восстановить JSON, добавляем текст напрямую');
                        try {
                            accumulatedText += event.data;
                            
                            // Обновляем содержимое сообщения
                            const contentDiv = streamingResponseDiv.querySelector('.message-content');
                            contentDiv.textContent = accumulatedText;
                            
                            // Добавляем курсор в конец сообщения
                            const cursor = document.createElement('div');
                            cursor.className = 'typing-cursor';
                            contentDiv.appendChild(cursor);
                            
                            // Прокручиваем историю к последнему сообщению
                            historyDiv.scrollTop = historyDiv.scrollHeight;
                        } catch (updateError) {
                            console.error('Ошибка при обновлении сообщения:', updateError);
                        }
                    }
                }
            };
            
            // Обработчик ошибок
            evtSource.onerror = function(error) {
                console.error('Ошибка EventSource:', error);
                
                // Проверяем состояние соединения
                if (evtSource.readyState === EventSource.CLOSED) {
                    console.log('Соединение закрыто');
                } else if (evtSource.readyState === EventSource.CONNECTING) {
                    console.log('Попытка повторного подключения...');
                    // Ждем автоматического повторного подключения
                    return;
                }
                
                statusDiv.className = 'status-indicator status-error';
                statusDiv.textContent = 'Ошибка при получении потокового ответа';
                
                // Закрываем соединение
                evtSource.close();
                currentStreamSource = null;
                
                // Сбрасываем состояние потока
                cleanupAfterStreaming();
                
                // Если ответ хотя бы частично получен, форматируем его
                if (accumulatedText.length > 0) {
                    completeStreaming(streamingResponseDiv);
                } else {
                    // Если ответ не получен, показываем сообщение об ошибке и предлагаем переключиться на обычный режим
                    const contentDiv = streamingResponseDiv.querySelector('.message-content');
                    contentDiv.innerHTML = `
                        <div class="error-message">
                            Ошибка при получении потокового ответа. 
                            Возможно, проблема с соединением или сервером. 
                            Попробуйте <button type="button" onclick="toggleStreamingMode(false)" class="retry-btn">отключить потоковый режим</button> и повторить запрос.
                        </div>
                    `;
                }
            };
            
            // Очищаем поле ввода
            messageInput.value = '';
        }
        
        // Функция для завершения потокового ответа
        function completeStreaming(responseDiv) {
            const statusDiv = document.getElementById('status');
            
            try {
                // Получаем содержимое сообщения и применяем форматирование Markdown
                const messageContentDiv = responseDiv.querySelector('.message-content');
                const content = messageContentDiv.textContent;
                
                // Удаляем элемент typing-cursor, если он есть
                const cursor = messageContentDiv.querySelector('.typing-cursor');
                if (cursor) {
                    cursor.remove();
                }
                
                // Применяем Markdown к содержимому
                messageContentDiv.innerHTML = marked.parse(content);
                
                // Применяем подсветку синтаксиса для блоков кода
                applyHighlightToCodeBlocks(messageContentDiv);
                
                // Рендерим LaTeX формулы, если они есть
                if (typeof MathJax !== 'undefined') {
                    MathJax.typesetPromise([messageContentDiv]).catch(function (err) {
                        console.error('Ошибка при рендеринге LaTeX:', err);
                    });
                }
            } catch (error) {
                console.error('Ошибка при форматировании ответа:', error);
            }
            
            // Показываем статус успеха
            statusDiv.className = 'status-indicator status-success';
            statusDiv.textContent = 'Ответ успешно получен';
            statusDiv.style.display = 'block';
            
            // Очищаем состояние потока
            cleanupAfterStreaming();
            
            // Обновляем счетчик сообщений
            updateMessageCount();
            
            // Прокручиваем к последнему сообщению
            historyDiv.scrollTop = historyDiv.scrollHeight;
        }
        
        // Обработка ответа от сервера (для обычного режима)
        function handleResponse(data) {
            const assistantMessageDiv = document.querySelector('.message-assistant:last-child');
            const messageContentDiv = assistantMessageDiv.querySelector('.message-content');
            
            try {
                // Применяем Markdown к содержимому
                messageContentDiv.innerHTML = marked.parse(data);
                
                // Применяем подсветку синтаксиса для блоков кода
                applyHighlightToCodeBlocks(messageContentDiv);
                
                // Рендерим LaTeX формулы, если они есть
                if (typeof MathJax !== 'undefined') {
                    MathJax.typesetPromise([messageContentDiv]).catch(function (err) {
                        console.error('Ошибка при рендеринге LaTeX:', err);
                    });
                }
            } catch (error) {
                console.error('Ошибка при форматировании ответа:', error);
                messageContentDiv.innerHTML = `<pre>${data}</pre>`;
            }
            
            isWaitingForResponse = false;
            updateUIState();
            
            // Обновляем время ответа
            const endTime = new Date();
            const responseTime = (endTime - startTime) / 1000;
            document.getElementById('response-time').textContent = `${responseTime.toFixed(2)} сек`;
            
            // Прокручиваем историю к последнему сообщению
            historyDiv.scrollTop = historyDiv.scrollHeight;
        }
        
        // Функция обновления счетчика сообщений
        function updateMessageCount() {
            const countSpan = document.getElementById('message-count');
            const messages = document.querySelectorAll('.message');
            countSpan.textContent = `Сообщений в истории: ${messages.length}`;
        }
        
        // Функция очистки после потокового ответа
        function cleanupAfterStreaming() {
            // Отключаем кнопку отмены
            document.getElementById('cancel-stream-btn').disabled = true;
            
            // Сбрасываем флаг ожидания ответа
            isWaitingForResponse = false;
            
            // Обновляем состояние интерфейса
            updateUIState();
            
            // Сбрасываем текущий источник событий
            if (currentStreamSource) {
                currentStreamSource.close();
                currentStreamSource = null;
            }
            
            // Сбрасываем идентификатор текущего ответа
            currentStreamingResponseId = null;
            
            // Обновляем время ответа
            if (startTime) {
                const endTime = new Date();
                const responseTime = (endTime - startTime) / 1000;
                document.getElementById('response-time').textContent = `${responseTime.toFixed(2)} сек`;
                startTime = null;
            }
        }
        
        // Обработчик обычного запроса
        function handleRegularRequest(message) {
            isWaitingForResponse = true;
            updateUIState();
            
            // Добавляем сообщение пользователя в историю
            addUserMessageToHistory(message);
            
            // Добавляем блок для ответа ассистента
            const assistantMessageDiv = document.createElement('div');
            assistantMessageDiv.className = 'message message-assistant';
            assistantMessageDiv.innerHTML = `
                <div class="message-role">
                    Ассистент
                    <span class="model-info">(${getModelNameById(document.getElementById('model-selector').value)})</span>
                </div>
                <div class="message-content"><div class="typing-cursor"></div></div>
            `;
            historyDiv.appendChild(assistantMessageDiv);
            
            // Прокручиваем историю к последнему сообщению
            historyDiv.scrollTop = historyDiv.scrollHeight;
            
            // Отправляем запрос на сервер
            startTime = new Date();
            
            fetch('/query', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: message,
                    stream: false
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Ошибка сети: ' + response.status);
                }
                return response.json();
            })
            .then(data => {
                // Обработка успешного ответа
                handleResponse(data.response);
            })
            .catch(error => {
                // Обработка ошибки
                console.error('Ошибка:', error);
                const messageContent = assistantMessageDiv.querySelector('.message-content');
                messageContent.innerHTML = `<div class="error-message">Произошла ошибка: ${error.message}</div>`;
                
                isWaitingForResponse = false;
                updateUIState();
            });
            
            // Очищаем поле ввода
            messageInput.value = '';
            
            // Обновляем счетчик сообщений
            updateMessageCount();
        }
        
        // Функция для отмены потокового запроса
        function cancelStream() {
            // Проверяем, есть ли активный источник событий
            if (currentStreamSource) {
                // Закрываем соединение
                currentStreamSource.close();
                currentStreamSource = null;
                
                // Показываем статус отмены
                const statusDiv = document.getElementById('status');
                statusDiv.className = 'status-indicator status-warning';
                statusDiv.textContent = 'Запрос отменен пользователем';
                statusDiv.style.display = 'block';
                
                // Очищаем состояние потока
                cleanupAfterStreaming();
                
                // Находим и обновляем блок ответа ассистента
                if (currentStreamingResponseId) {
                    const streamingResponseDiv = document.getElementById(currentStreamingResponseId);
                    if (streamingResponseDiv) {
                        const contentDiv = streamingResponseDiv.querySelector('.message-content');
                        if (contentDiv) {
                            // Удаляем курсор, если есть
                            const cursor = contentDiv.querySelector('.typing-cursor');
                            if (cursor) {
                                cursor.remove();
                            }
                            
                            // Добавляем метку отмены
                            contentDiv.innerHTML += '<div class="cancel-message">[Запрос отменен пользователем]</div>';
                        }
                    }
                }
            }
        }
        
        // Функция обновления состояния интерфейса
        function updateUIState() {
            const submitBtn = document.getElementById('submit-btn');
            const messageInput = document.getElementById('message-input');
            const cancelStreamBtn = document.getElementById('cancel-stream-btn');
            
            // Обновляем состояние кнопок и полей ввода
            submitBtn.disabled = isWaitingForResponse;
            messageInput.disabled = isWaitingForResponse;
            
            // Показываем/скрываем кнопку отмены в зависимости от состояния
            if (isWaitingForResponse && isStreaming) {
                cancelStreamBtn.style.display = 'inline-block';
                submitBtn.style.display = 'none';
            } else {
                cancelStreamBtn.style.display = 'none';
                submitBtn.style.display = 'inline-block';
            }
        }
        
        // Функция для переключения режима потоковой передачи
        function toggleStreamingMode(enable) {
            isStreaming = enable;
            const streamToggle = document.getElementById('stream-toggle');
            streamToggle.classList.toggle('active', isStreaming);
            streamToggle.textContent = isStreaming ? 'Стриминг: вкл' : 'Стриминг: выкл';
        }
        
        // Функция для проверки статуса API
        function checkAPIStatus() {
            const statusDiv = document.getElementById('status');
            
            // Показываем статус загрузки
            statusDiv.className = 'status-indicator status-loading';
            statusDiv.textContent = 'Проверка соединения с API...';
            statusDiv.style.display = 'block';
            
            fetch('/api-status')
            .then(response => response.json())
            .then(data => {
                if (data.status === 'ok') {
                    statusDiv.className = 'status-indicator status-success';
                    statusDiv.textContent = 'API готов к работе';
                    
                    // Скрываем статус через 5 секунд
                    setTimeout(() => {
                        statusDiv.style.display = 'none';
                    }, 5000);
                } else {
                    statusDiv.className = 'status-indicator status-error';
                    statusDiv.textContent = 'Проблема с API: ' + data.message;
                    console.error('Проблема с API:', data.message);
                }
            })
            .catch(error => {
                statusDiv.className = 'status-indicator status-error';
                statusDiv.textContent = 'Ошибка при проверке API: ' + error.message;
                console.error('Ошибка при проверке API:', error);
            });
        }
        
        // Функция для загрузки доступных моделей
        function loadAvailableModels() {
            const modelSelector = document.getElementById('model-selector');
            const statusDiv = document.getElementById('status');
            
            fetch('/models')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Не удалось получить список моделей');
                }
                return response.json();
            })
            .then(data => {
                // Очищаем селектор
                modelSelector.innerHTML = '';
                
                // Добавляем опции для каждой модели
                data.models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.name;
                    
                    // Устанавливаем выбранную модель
                    if (model.id === data.currentModel) {
                        option.selected = true;
                    }
                    
                    modelSelector.appendChild(option);
                });
                
                console.log('Модели загружены:', data.models.length);
            })
            .catch(error => {
                console.error('Ошибка при загрузке моделей:', error);
                
                // Показываем ошибку
                statusDiv.className = 'status-indicator status-error';
                statusDiv.textContent = 'Ошибка при загрузке моделей: ' + error.message;
                statusDiv.style.display = 'block';
                
                // Устанавливаем опцию ошибки
                modelSelector.innerHTML = '<option value="error">Ошибка загрузки моделей</option>';
            });
        }
        
        // Функция для установки текущей модели
        function setCurrentModel(modelId) {
            const statusDiv = document.getElementById('status');
            
            // Показываем статус загрузки
            statusDiv.className = 'status-indicator status-loading';
            statusDiv.textContent = 'Изменение модели...';
            statusDiv.style.display = 'block';
            
            fetch('/set-model', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    modelId: modelId
                })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.message || 'Ошибка при изменении модели');
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log('Модель успешно изменена:', data.model);
                
                // Показываем успешный статус
                statusDiv.className = 'status-indicator status-success';
                statusDiv.textContent = 'Модель успешно изменена на ' + getModelNameById(modelId);
                statusDiv.style.display = 'block';
                
                // Скрываем статус через 3 секунды
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            })
            .catch(error => {
                console.error('Ошибка при изменении модели:', error);
                
                // Показываем ошибку
                statusDiv.className = 'status-indicator status-error';
                statusDiv.textContent = 'Ошибка при изменении модели: ' + error.message;
                statusDiv.style.display = 'block';
                
                // Перезагружаем модели для восстановления правильного выбора
                loadAvailableModels();
            });
        }
        
        // Функция для получения названия модели по ID
        function getModelNameById(modelId) {
            const modelSelector = document.getElementById('model-selector');
            for (const option of modelSelector.options) {
                if (option.value === modelId) {
                    return option.textContent;
                }
            }
            return modelId; // Возвращаем ID, если название не найдено
        }
    </script>
</body>
</html> 